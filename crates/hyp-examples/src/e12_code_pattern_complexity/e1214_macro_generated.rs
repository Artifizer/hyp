/// E1214: Macro-generated trait implementations
/// Severity: MED
/// LLM confusion: 5 (HIGHEST)
///
/// Description: This code uses macros to generate trait implementations, making it very hard to
/// understand what code actually exists. Macros are like code generators - the actual code doesn't
/// exist in the source file, it's created by the macro. This is extremely confusing because you
/// can't "go to definition" or see the actual implementation. It's like having invisible code.
/// Fix by writing out implementations manually or using procedural macros with better tooling.
///
/// Mitigation: Use macros sparingly. When needed, provide examples of expanded macro output.
/// Prefer procedural macros over declarative macros for complex generation. Use `cargo expand`
/// to see generated code. Document what the macro generates clearly.

// PROBLEM E1214: Macro generates repetitive trait implementations
macro_rules! impl_numeric_traits {
    ($($t:ty),*) => {
        $(
            // PROBLEM E1214: This implementation is hidden in the macro
            impl NumericOps for $t {
                fn double(&self) -> Self {
                    self * 2 as $t
                }

                fn add_one(&self) -> Self {
                    self + 1 as $t
                }

                fn is_even(&self) -> bool {
                    self % 2 as $t == 0 as $t
                }
            }
        )*
    };
}

pub trait NumericOps {
    fn double(&self) -> Self;
    fn add_one(&self) -> Self;
    fn is_even(&self) -> bool;
}

// PROBLEM E1214: Multiple implementations generated by one macro call
impl_numeric_traits!(i8, i16, i32, i64, u8, u16, u32, u64);

// PROBLEM E1214: Nested macro for complex trait implementations
macro_rules! define_wrapper {
    ($name:ident, $inner:ty) => {
        pub struct $name {
            value: $inner,
        }

        impl $name {
            pub fn new(value: $inner) -> Self {
                $name { value }
            }

            pub fn get(&self) -> $inner {
                self.value
            }
        }

        impl std::ops::Add for $name {
            type Output = Self;

            fn add(self, other: Self) -> Self {
                $name {
                    value: self.value + other.value,
                }
            }
        }
    };
}

// PROBLEM E1214: Types and implementations created by macro
define_wrapper!(IntWrapper, i32);
define_wrapper!(FloatWrapper, f64);

pub fn e1214_bad_macro_generated() {
    let a = IntWrapper::new(5);
    let b = IntWrapper::new(3);
    let _c = a + b; // Add impl generated by macro

    let x: i32 = 42;
    let _doubled = x.double(); // Impl generated by macro
}

pub fn e1214_entry() -> Result<(), Box<dyn std::error::Error>> {
    e1214_bad_macro_generated();
    Ok(())
}
